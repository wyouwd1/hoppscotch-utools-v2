// uTools Hoppscotch 核心协议功能测试模块
// 测试 HTTP、WebSocket、MQTT、GraphQL 等协议的基础功能

import { getFeatureConfig, isFeatureEnabled } from '../config/features.js'\nimport { utoolsStorage } from '../platform/storage.js'\n\n// 测试结果接口\nexport interface TestResult {\n  protocol: string\n  name: string\n  status: 'success' | 'error' | 'warning' | 'skipped'\n  message: string\n  duration?: number\n  details?: any\n}\n\n// 协议测试管理器\nexport class ProtocolTester {\n  private results: TestResult[] = []\n  \n  // 运行所有协议测试\n  async runAllTests(): Promise<TestResult[]> {\n    console.log('🧪 开始运行核心协议功能测试...')\n    \n    this.results = []\n    \n    // 测试功能配置系统\n    await this.testFeatureConfig()\n    \n    // 测试HTTP协议功能\n    if (isFeatureEnabled('protocols.http')) {\n      await this.testHTTPProtocol()\n    } else {\n      this.addResult('HTTP', '协议检查', 'skipped', 'HTTP协议已禁用')\n    }\n    \n    // 测试WebSocket协议功能\n    if (isFeatureEnabled('protocols.websocket')) {\n      await this.testWebSocketProtocol()\n    } else {\n      this.addResult('WebSocket', '协议检查', 'skipped', 'WebSocket协议已禁用')\n    }\n    \n    // 测试MQTT协议功能\n    if (isFeatureEnabled('protocols.mqtt')) {\n      await this.testMQTTProtocol()\n    } else {\n      this.addResult('MQTT', '协议检查', 'skipped', 'MQTT协议已禁用')\n    }\n    \n    // 测试GraphQL协议功能\n    if (isFeatureEnabled('protocols.graphql')) {\n      await this.testGraphQLProtocol()\n    } else {\n      this.addResult('GraphQL', '协议检查', 'skipped', 'GraphQL协议已禁用')\n    }\n    \n    // 测试数据管理功能\n    await this.testDataManagement()\n    \n    console.log('✅ 协议功能测试完成，共运行', this.results.length, '个测试')\n    \n    return this.results\n  }\n  \n  // 添加测试结果\n  private addResult(\n    protocol: string, \n    name: string, \n    status: TestResult['status'], \n    message: string, \n    details?: any\n  ): void {\n    this.results.push({\n      protocol,\n      name,\n      status,\n      message,\n      details\n    })\n  }\n  \n  // 执行带计时的测试\n  private async runTimedTest(\n    protocol: string,\n    name: string,\n    testFn: () => Promise<any>\n  ): Promise<void> {\n    const startTime = Date.now()\n    \n    try {\n      const result = await testFn()\n      const duration = Date.now() - startTime\n      \n      this.addResult(protocol, name, 'success', '测试通过', { duration, result })\n    } catch (error) {\n      const duration = Date.now() - startTime\n      this.addResult(protocol, name, 'error', error.message, { duration, error })\n    }\n  }\n  \n  // 测试功能配置系统\n  private async testFeatureConfig(): Promise<void> {\n    await this.runTimedTest('Config', '功能配置加载', async () => {\n      const config = getFeatureConfig()\n      \n      if (!config || typeof config !== 'object') {\n        throw new Error('功能配置加载失败')\n      }\n      \n      // 验证核心配置项\n      const requiredSections = ['protocols', 'dataManagement', 'ui', 'disabled']\n      for (const section of requiredSections) {\n        if (!config[section]) {\n          throw new Error(`缺少必需的配置节: ${section}`)\n        }\n      }\n      \n      return {\n        enabledProtocols: Object.entries(config.protocols)\n          .filter(([_, enabled]) => enabled)\n          .map(([name, _]) => name),\n        configSections: Object.keys(config)\n      }\n    })\n  }\n  \n  // 测试HTTP协议功能\n  private async testHTTPProtocol(): Promise<void> {\n    // 测试HTTP请求构建\n    await this.runTimedTest('HTTP', 'HTTP请求构建', async () => {\n      const request = {\n        method: 'GET',\n        url: 'https://httpbin.org/get',\n        headers: {\n          'Content-Type': 'application/json',\n          'User-Agent': 'Hoppscotch-uTools/1.0'\n        }\n      }\n      \n      // 验证请求对象结构\n      if (!request.method || !request.url) {\n        throw new Error('HTTP请求对象结构不完整')\n      }\n      \n      return request\n    })\n    \n    // 测试HTTP响应解析\n    await this.runTimedTest('HTTP', 'HTTP响应解析', async () => {\n      const mockResponse = {\n        status: 200,\n        statusText: 'OK',\n        headers: {\n          'content-type': 'application/json'\n        },\n        data: { message: 'Hello from uTools Hoppscotch!' }\n      }\n      \n      // 验证响应解析逻辑\n      if (mockResponse.status < 200 || mockResponse.status >= 600) {\n        throw new Error('无效的HTTP状态码')\n      }\n      \n      return {\n        statusCode: mockResponse.status,\n        contentType: mockResponse.headers['content-type'],\n        hasData: !!mockResponse.data\n      }\n    })\n    \n    // 测试HTTP错误处理\n    await this.runTimedTest('HTTP', 'HTTP错误处理', async () => {\n      const errors = [\n        { code: 400, message: 'Bad Request' },\n        { code: 404, message: 'Not Found' },\n        { code: 500, message: 'Internal Server Error' }\n      ]\n      \n      const handled = errors.map(error => ({\n        ...error,\n        category: error.code < 500 ? 'client' : 'server',\n        handled: true\n      }))\n      \n      return { errorCount: errors.length, handledErrors: handled }\n    })\n  }\n  \n  // 测试WebSocket协议功能\n  private async testWebSocketProtocol(): Promise<void> {\n    // 测试WebSocket连接配置\n    await this.runTimedTest('WebSocket', 'WebSocket连接配置', async () => {\n      const wsConfig = {\n        url: 'wss://echo.websocket.org',\n        protocols: [],\n        headers: {},\n        reconnect: true,\n        reconnectInterval: 1000\n      }\n      \n      // 验证WebSocket URL格式\n      if (!wsConfig.url.startsWith('ws://') && !wsConfig.url.startsWith('wss://')) {\n        throw new Error('无效的WebSocket URL格式')\n      }\n      \n      return wsConfig\n    })\n    \n    // 测试WebSocket消息处理\n    await this.runTimedTest('WebSocket', 'WebSocket消息处理', async () => {\n      const messages = [\n        { type: 'text', data: 'Hello WebSocket!' },\n        { type: 'json', data: { message: 'JSON message', timestamp: Date.now() } },\n        { type: 'binary', data: new ArrayBuffer(8) }\n      ]\n      \n      const processed = messages.map(msg => ({\n        type: msg.type,\n        size: typeof msg.data === 'string' ? msg.data.length : \n              msg.data instanceof ArrayBuffer ? msg.data.byteLength :\n              JSON.stringify(msg.data).length,\n        processed: true\n      }))\n      \n      return { messageCount: messages.length, processedMessages: processed }\n    })\n  }\n  \n  // 测试MQTT协议功能\n  private async testMQTTProtocol(): Promise<void> {\n    // 测试MQTT连接配置\n    await this.runTimedTest('MQTT', 'MQTT连接配置', async () => {\n      const mqttConfig = {\n        broker: 'mqtt://test.mosquitto.org',\n        port: 1883,\n        clientId: 'hoppscotch-utools-' + Math.random().toString(36).substr(2, 9),\n        username: '',\n        password: '',\n        keepAlive: 60,\n        clean: true\n      }\n      \n      // 验证MQTT配置\n      if (!mqttConfig.broker || !mqttConfig.clientId) {\n        throw new Error('MQTT配置不完整')\n      }\n      \n      return mqttConfig\n    })\n    \n    // 测试MQTT主题订阅\n    await this.runTimedTest('MQTT', 'MQTT主题订阅', async () => {\n      const subscriptions = [\n        { topic: 'test/hoppscotch', qos: 0 },\n        { topic: 'sensors/+/temperature', qos: 1 },\n        { topic: 'logs/#', qos: 2 }\n      ]\n      \n      // 验证主题格式\n      for (const sub of subscriptions) {\n        if (!sub.topic || sub.qos < 0 || sub.qos > 2) {\n          throw new Error(`无效的MQTT订阅: ${sub.topic}`)\n        }\n      }\n      \n      return { subscriptionCount: subscriptions.length, topics: subscriptions }\n    })\n  }\n  \n  // 测试GraphQL协议功能\n  private async testGraphQLProtocol(): Promise<void> {\n    // 测试GraphQL查询构建\n    await this.runTimedTest('GraphQL', 'GraphQL查询构建', async () => {\n      const query = `\n        query GetUser($id: ID!) {\n          user(id: $id) {\n            id\n            name\n            email\n            posts {\n              title\n              content\n            }\n          }\n        }\n      `\n      \n      const variables = { id: '123' }\n      \n      // 基础GraphQL语法验证\n      if (!query.includes('query') && !query.includes('mutation')) {\n        throw new Error('无效的GraphQL查询')\n      }\n      \n      return {\n        queryType: query.includes('mutation') ? 'mutation' : 'query',\n        hasVariables: Object.keys(variables).length > 0,\n        queryLength: query.length\n      }\n    })\n    \n    // 测试GraphQL Schema解析\n    await this.runTimedTest('GraphQL', 'GraphQL Schema解析', async () => {\n      const mockSchema = `\n        type User {\n          id: ID!\n          name: String!\n          email: String\n        }\n        \n        type Query {\n          user(id: ID!): User\n          users: [User!]!\n        }\n      `\n      \n      // 模拟Schema解析\n      const types = mockSchema.match(/type\\s+(\\w+)/g) || []\n      const fields = mockSchema.match(/(\\w+)\\s*(?:\\([^)]*\\))?\\s*:/g) || []\n      \n      return {\n        typeCount: types.length,\n        fieldCount: fields.length,\n        hasQuery: mockSchema.includes('type Query')\n      }\n    })\n  }\n  \n  // 测试数据管理功能\n  private async testDataManagement(): Promise<void> {\n    // 测试集合管理\n    if (isFeatureEnabled('dataManagement.collections')) {\n      await this.runTimedTest('Collections', '集合存储', async () => {\n        const testCollection = {\n          id: 'test-collection-' + Date.now(),\n          name: '测试集合',\n          requests: [\n            {\n              id: 'req-1',\n              name: '测试请求',\n              method: 'GET',\n              url: 'https://api.example.com/test'\n            }\n          ]\n        }\n        \n        // 模拟保存集合\n        await utoolsStorage.set(`collection_${testCollection.id}`, testCollection)\n        \n        // 验证保存结果\n        const saved = await utoolsStorage.get(`collection_${testCollection.id}`)\n        if (!saved || saved.name !== testCollection.name) {\n          throw new Error('集合保存失败')\n        }\n        \n        // 清理测试数据\n        await utoolsStorage.remove(`collection_${testCollection.id}`)\n        \n        return { collectionId: testCollection.id, requestCount: testCollection.requests.length }\n      })\n    }\n    \n    // 测试环境变量管理\n    if (isFeatureEnabled('dataManagement.environments')) {\n      await this.runTimedTest('Environments', '环境变量存储', async () => {\n        const testEnv = {\n          id: 'test-env-' + Date.now(),\n          name: '测试环境',\n          variables: {\n            BASE_URL: 'https://api.test.com',\n            API_KEY: 'test-key-12345',\n            VERSION: 'v1'\n          }\n        }\n        \n        // 模拟保存环境\n        await utoolsStorage.set(`environment_${testEnv.id}`, testEnv)\n        \n        // 验证保存结果\n        const saved = await utoolsStorage.get(`environment_${testEnv.id}`)\n        if (!saved || Object.keys(saved.variables).length !== 3) {\n          throw new Error('环境变量保存失败')\n        }\n        \n        // 清理测试数据\n        await utoolsStorage.remove(`environment_${testEnv.id}`)\n        \n        return { environmentId: testEnv.id, variableCount: Object.keys(testEnv.variables).length }\n      })\n    }\n    \n    // 测试历史记录管理\n    if (isFeatureEnabled('dataManagement.history')) {\n      await this.runTimedTest('History', '历史记录存储', async () => {\n        const testHistory = {\n          id: 'test-history-' + Date.now(),\n          timestamp: Date.now(),\n          method: 'POST',\n          url: 'https://api.example.com/users',\n          status: 201,\n          duration: 156\n        }\n        \n        // 模拟保存历史记录\n        await utoolsStorage.set(`history_${testHistory.id}`, testHistory)\n        \n        // 验证保存结果\n        const saved = await utoolsStorage.get(`history_${testHistory.id}`)\n        if (!saved || saved.method !== testHistory.method) {\n          throw new Error('历史记录保存失败')\n        }\n        \n        // 清理测试数据\n        await utoolsStorage.remove(`history_${testHistory.id}`)\n        \n        return { historyId: testHistory.id, method: testHistory.method, status: testHistory.status }\n      })\n    }\n  }\n  \n  // 获取测试摘要\n  getTestSummary(): { total: number, passed: number, failed: number, skipped: number, warnings: number } {\n    const total = this.results.length\n    const passed = this.results.filter(r => r.status === 'success').length\n    const failed = this.results.filter(r => r.status === 'error').length\n    const skipped = this.results.filter(r => r.status === 'skipped').length\n    const warnings = this.results.filter(r => r.status === 'warning').length\n    \n    return { total, passed, failed, skipped, warnings }\n  }\n  \n  // 获取测试结果\n  getResults(): TestResult[] {\n    return this.results\n  }\n}\n\n// 导出测试实例\nexport const protocolTester = new ProtocolTester()\n\n// 便捷测试函数\nexport async function runProtocolTests(): Promise<TestResult[]> {\n  return await protocolTester.runAllTests()\n}\n\nexport function getTestSummary(): ReturnType<ProtocolTester['getTestSummary']> {\n  return protocolTester.getTestSummary()\n}