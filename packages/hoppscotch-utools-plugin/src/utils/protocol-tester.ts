// uTools Hoppscotch æ ¸å¿ƒåè®®åŠŸèƒ½æµ‹è¯•æ¨¡å—
// æµ‹è¯• HTTPã€WebSocketã€MQTTã€GraphQL ç­‰åè®®çš„åŸºç¡€åŠŸèƒ½

import { getFeatureConfig, isFeatureEnabled } from '../config/features.js'\nimport { utoolsStorage } from '../platform/storage.js'\n\n// æµ‹è¯•ç»“æœæ¥å£\nexport interface TestResult {\n  protocol: string\n  name: string\n  status: 'success' | 'error' | 'warning' | 'skipped'\n  message: string\n  duration?: number\n  details?: any\n}\n\n// åè®®æµ‹è¯•ç®¡ç†å™¨\nexport class ProtocolTester {\n  private results: TestResult[] = []\n  \n  // è¿è¡Œæ‰€æœ‰åè®®æµ‹è¯•\n  async runAllTests(): Promise<TestResult[]> {\n    console.log('ğŸ§ª å¼€å§‹è¿è¡Œæ ¸å¿ƒåè®®åŠŸèƒ½æµ‹è¯•...')\n    \n    this.results = []\n    \n    // æµ‹è¯•åŠŸèƒ½é…ç½®ç³»ç»Ÿ\n    await this.testFeatureConfig()\n    \n    // æµ‹è¯•HTTPåè®®åŠŸèƒ½\n    if (isFeatureEnabled('protocols.http')) {\n      await this.testHTTPProtocol()\n    } else {\n      this.addResult('HTTP', 'åè®®æ£€æŸ¥', 'skipped', 'HTTPåè®®å·²ç¦ç”¨')\n    }\n    \n    // æµ‹è¯•WebSocketåè®®åŠŸèƒ½\n    if (isFeatureEnabled('protocols.websocket')) {\n      await this.testWebSocketProtocol()\n    } else {\n      this.addResult('WebSocket', 'åè®®æ£€æŸ¥', 'skipped', 'WebSocketåè®®å·²ç¦ç”¨')\n    }\n    \n    // æµ‹è¯•MQTTåè®®åŠŸèƒ½\n    if (isFeatureEnabled('protocols.mqtt')) {\n      await this.testMQTTProtocol()\n    } else {\n      this.addResult('MQTT', 'åè®®æ£€æŸ¥', 'skipped', 'MQTTåè®®å·²ç¦ç”¨')\n    }\n    \n    // æµ‹è¯•GraphQLåè®®åŠŸèƒ½\n    if (isFeatureEnabled('protocols.graphql')) {\n      await this.testGraphQLProtocol()\n    } else {\n      this.addResult('GraphQL', 'åè®®æ£€æŸ¥', 'skipped', 'GraphQLåè®®å·²ç¦ç”¨')\n    }\n    \n    // æµ‹è¯•æ•°æ®ç®¡ç†åŠŸèƒ½\n    await this.testDataManagement()\n    \n    console.log('âœ… åè®®åŠŸèƒ½æµ‹è¯•å®Œæˆï¼Œå…±è¿è¡Œ', this.results.length, 'ä¸ªæµ‹è¯•')\n    \n    return this.results\n  }\n  \n  // æ·»åŠ æµ‹è¯•ç»“æœ\n  private addResult(\n    protocol: string, \n    name: string, \n    status: TestResult['status'], \n    message: string, \n    details?: any\n  ): void {\n    this.results.push({\n      protocol,\n      name,\n      status,\n      message,\n      details\n    })\n  }\n  \n  // æ‰§è¡Œå¸¦è®¡æ—¶çš„æµ‹è¯•\n  private async runTimedTest(\n    protocol: string,\n    name: string,\n    testFn: () => Promise<any>\n  ): Promise<void> {\n    const startTime = Date.now()\n    \n    try {\n      const result = await testFn()\n      const duration = Date.now() - startTime\n      \n      this.addResult(protocol, name, 'success', 'æµ‹è¯•é€šè¿‡', { duration, result })\n    } catch (error) {\n      const duration = Date.now() - startTime\n      this.addResult(protocol, name, 'error', error.message, { duration, error })\n    }\n  }\n  \n  // æµ‹è¯•åŠŸèƒ½é…ç½®ç³»ç»Ÿ\n  private async testFeatureConfig(): Promise<void> {\n    await this.runTimedTest('Config', 'åŠŸèƒ½é…ç½®åŠ è½½', async () => {\n      const config = getFeatureConfig()\n      \n      if (!config || typeof config !== 'object') {\n        throw new Error('åŠŸèƒ½é…ç½®åŠ è½½å¤±è´¥')\n      }\n      \n      // éªŒè¯æ ¸å¿ƒé…ç½®é¡¹\n      const requiredSections = ['protocols', 'dataManagement', 'ui', 'disabled']\n      for (const section of requiredSections) {\n        if (!config[section]) {\n          throw new Error(`ç¼ºå°‘å¿…éœ€çš„é…ç½®èŠ‚: ${section}`)\n        }\n      }\n      \n      return {\n        enabledProtocols: Object.entries(config.protocols)\n          .filter(([_, enabled]) => enabled)\n          .map(([name, _]) => name),\n        configSections: Object.keys(config)\n      }\n    })\n  }\n  \n  // æµ‹è¯•HTTPåè®®åŠŸèƒ½\n  private async testHTTPProtocol(): Promise<void> {\n    // æµ‹è¯•HTTPè¯·æ±‚æ„å»º\n    await this.runTimedTest('HTTP', 'HTTPè¯·æ±‚æ„å»º', async () => {\n      const request = {\n        method: 'GET',\n        url: 'https://httpbin.org/get',\n        headers: {\n          'Content-Type': 'application/json',\n          'User-Agent': 'Hoppscotch-uTools/1.0'\n        }\n      }\n      \n      // éªŒè¯è¯·æ±‚å¯¹è±¡ç»“æ„\n      if (!request.method || !request.url) {\n        throw new Error('HTTPè¯·æ±‚å¯¹è±¡ç»“æ„ä¸å®Œæ•´')\n      }\n      \n      return request\n    })\n    \n    // æµ‹è¯•HTTPå“åº”è§£æ\n    await this.runTimedTest('HTTP', 'HTTPå“åº”è§£æ', async () => {\n      const mockResponse = {\n        status: 200,\n        statusText: 'OK',\n        headers: {\n          'content-type': 'application/json'\n        },\n        data: { message: 'Hello from uTools Hoppscotch!' }\n      }\n      \n      // éªŒè¯å“åº”è§£æé€»è¾‘\n      if (mockResponse.status < 200 || mockResponse.status >= 600) {\n        throw new Error('æ— æ•ˆçš„HTTPçŠ¶æ€ç ')\n      }\n      \n      return {\n        statusCode: mockResponse.status,\n        contentType: mockResponse.headers['content-type'],\n        hasData: !!mockResponse.data\n      }\n    })\n    \n    // æµ‹è¯•HTTPé”™è¯¯å¤„ç†\n    await this.runTimedTest('HTTP', 'HTTPé”™è¯¯å¤„ç†', async () => {\n      const errors = [\n        { code: 400, message: 'Bad Request' },\n        { code: 404, message: 'Not Found' },\n        { code: 500, message: 'Internal Server Error' }\n      ]\n      \n      const handled = errors.map(error => ({\n        ...error,\n        category: error.code < 500 ? 'client' : 'server',\n        handled: true\n      }))\n      \n      return { errorCount: errors.length, handledErrors: handled }\n    })\n  }\n  \n  // æµ‹è¯•WebSocketåè®®åŠŸèƒ½\n  private async testWebSocketProtocol(): Promise<void> {\n    // æµ‹è¯•WebSocketè¿æ¥é…ç½®\n    await this.runTimedTest('WebSocket', 'WebSocketè¿æ¥é…ç½®', async () => {\n      const wsConfig = {\n        url: 'wss://echo.websocket.org',\n        protocols: [],\n        headers: {},\n        reconnect: true,\n        reconnectInterval: 1000\n      }\n      \n      // éªŒè¯WebSocket URLæ ¼å¼\n      if (!wsConfig.url.startsWith('ws://') && !wsConfig.url.startsWith('wss://')) {\n        throw new Error('æ— æ•ˆçš„WebSocket URLæ ¼å¼')\n      }\n      \n      return wsConfig\n    })\n    \n    // æµ‹è¯•WebSocketæ¶ˆæ¯å¤„ç†\n    await this.runTimedTest('WebSocket', 'WebSocketæ¶ˆæ¯å¤„ç†', async () => {\n      const messages = [\n        { type: 'text', data: 'Hello WebSocket!' },\n        { type: 'json', data: { message: 'JSON message', timestamp: Date.now() } },\n        { type: 'binary', data: new ArrayBuffer(8) }\n      ]\n      \n      const processed = messages.map(msg => ({\n        type: msg.type,\n        size: typeof msg.data === 'string' ? msg.data.length : \n              msg.data instanceof ArrayBuffer ? msg.data.byteLength :\n              JSON.stringify(msg.data).length,\n        processed: true\n      }))\n      \n      return { messageCount: messages.length, processedMessages: processed }\n    })\n  }\n  \n  // æµ‹è¯•MQTTåè®®åŠŸèƒ½\n  private async testMQTTProtocol(): Promise<void> {\n    // æµ‹è¯•MQTTè¿æ¥é…ç½®\n    await this.runTimedTest('MQTT', 'MQTTè¿æ¥é…ç½®', async () => {\n      const mqttConfig = {\n        broker: 'mqtt://test.mosquitto.org',\n        port: 1883,\n        clientId: 'hoppscotch-utools-' + Math.random().toString(36).substr(2, 9),\n        username: '',\n        password: '',\n        keepAlive: 60,\n        clean: true\n      }\n      \n      // éªŒè¯MQTTé…ç½®\n      if (!mqttConfig.broker || !mqttConfig.clientId) {\n        throw new Error('MQTTé…ç½®ä¸å®Œæ•´')\n      }\n      \n      return mqttConfig\n    })\n    \n    // æµ‹è¯•MQTTä¸»é¢˜è®¢é˜…\n    await this.runTimedTest('MQTT', 'MQTTä¸»é¢˜è®¢é˜…', async () => {\n      const subscriptions = [\n        { topic: 'test/hoppscotch', qos: 0 },\n        { topic: 'sensors/+/temperature', qos: 1 },\n        { topic: 'logs/#', qos: 2 }\n      ]\n      \n      // éªŒè¯ä¸»é¢˜æ ¼å¼\n      for (const sub of subscriptions) {\n        if (!sub.topic || sub.qos < 0 || sub.qos > 2) {\n          throw new Error(`æ— æ•ˆçš„MQTTè®¢é˜…: ${sub.topic}`)\n        }\n      }\n      \n      return { subscriptionCount: subscriptions.length, topics: subscriptions }\n    })\n  }\n  \n  // æµ‹è¯•GraphQLåè®®åŠŸèƒ½\n  private async testGraphQLProtocol(): Promise<void> {\n    // æµ‹è¯•GraphQLæŸ¥è¯¢æ„å»º\n    await this.runTimedTest('GraphQL', 'GraphQLæŸ¥è¯¢æ„å»º', async () => {\n      const query = `\n        query GetUser($id: ID!) {\n          user(id: $id) {\n            id\n            name\n            email\n            posts {\n              title\n              content\n            }\n          }\n        }\n      `\n      \n      const variables = { id: '123' }\n      \n      // åŸºç¡€GraphQLè¯­æ³•éªŒè¯\n      if (!query.includes('query') && !query.includes('mutation')) {\n        throw new Error('æ— æ•ˆçš„GraphQLæŸ¥è¯¢')\n      }\n      \n      return {\n        queryType: query.includes('mutation') ? 'mutation' : 'query',\n        hasVariables: Object.keys(variables).length > 0,\n        queryLength: query.length\n      }\n    })\n    \n    // æµ‹è¯•GraphQL Schemaè§£æ\n    await this.runTimedTest('GraphQL', 'GraphQL Schemaè§£æ', async () => {\n      const mockSchema = `\n        type User {\n          id: ID!\n          name: String!\n          email: String\n        }\n        \n        type Query {\n          user(id: ID!): User\n          users: [User!]!\n        }\n      `\n      \n      // æ¨¡æ‹ŸSchemaè§£æ\n      const types = mockSchema.match(/type\\s+(\\w+)/g) || []\n      const fields = mockSchema.match(/(\\w+)\\s*(?:\\([^)]*\\))?\\s*:/g) || []\n      \n      return {\n        typeCount: types.length,\n        fieldCount: fields.length,\n        hasQuery: mockSchema.includes('type Query')\n      }\n    })\n  }\n  \n  // æµ‹è¯•æ•°æ®ç®¡ç†åŠŸèƒ½\n  private async testDataManagement(): Promise<void> {\n    // æµ‹è¯•é›†åˆç®¡ç†\n    if (isFeatureEnabled('dataManagement.collections')) {\n      await this.runTimedTest('Collections', 'é›†åˆå­˜å‚¨', async () => {\n        const testCollection = {\n          id: 'test-collection-' + Date.now(),\n          name: 'æµ‹è¯•é›†åˆ',\n          requests: [\n            {\n              id: 'req-1',\n              name: 'æµ‹è¯•è¯·æ±‚',\n              method: 'GET',\n              url: 'https://api.example.com/test'\n            }\n          ]\n        }\n        \n        // æ¨¡æ‹Ÿä¿å­˜é›†åˆ\n        await utoolsStorage.set(`collection_${testCollection.id}`, testCollection)\n        \n        // éªŒè¯ä¿å­˜ç»“æœ\n        const saved = await utoolsStorage.get(`collection_${testCollection.id}`)\n        if (!saved || saved.name !== testCollection.name) {\n          throw new Error('é›†åˆä¿å­˜å¤±è´¥')\n        }\n        \n        // æ¸…ç†æµ‹è¯•æ•°æ®\n        await utoolsStorage.remove(`collection_${testCollection.id}`)\n        \n        return { collectionId: testCollection.id, requestCount: testCollection.requests.length }\n      })\n    }\n    \n    // æµ‹è¯•ç¯å¢ƒå˜é‡ç®¡ç†\n    if (isFeatureEnabled('dataManagement.environments')) {\n      await this.runTimedTest('Environments', 'ç¯å¢ƒå˜é‡å­˜å‚¨', async () => {\n        const testEnv = {\n          id: 'test-env-' + Date.now(),\n          name: 'æµ‹è¯•ç¯å¢ƒ',\n          variables: {\n            BASE_URL: 'https://api.test.com',\n            API_KEY: 'test-key-12345',\n            VERSION: 'v1'\n          }\n        }\n        \n        // æ¨¡æ‹Ÿä¿å­˜ç¯å¢ƒ\n        await utoolsStorage.set(`environment_${testEnv.id}`, testEnv)\n        \n        // éªŒè¯ä¿å­˜ç»“æœ\n        const saved = await utoolsStorage.get(`environment_${testEnv.id}`)\n        if (!saved || Object.keys(saved.variables).length !== 3) {\n          throw new Error('ç¯å¢ƒå˜é‡ä¿å­˜å¤±è´¥')\n        }\n        \n        // æ¸…ç†æµ‹è¯•æ•°æ®\n        await utoolsStorage.remove(`environment_${testEnv.id}`)\n        \n        return { environmentId: testEnv.id, variableCount: Object.keys(testEnv.variables).length }\n      })\n    }\n    \n    // æµ‹è¯•å†å²è®°å½•ç®¡ç†\n    if (isFeatureEnabled('dataManagement.history')) {\n      await this.runTimedTest('History', 'å†å²è®°å½•å­˜å‚¨', async () => {\n        const testHistory = {\n          id: 'test-history-' + Date.now(),\n          timestamp: Date.now(),\n          method: 'POST',\n          url: 'https://api.example.com/users',\n          status: 201,\n          duration: 156\n        }\n        \n        // æ¨¡æ‹Ÿä¿å­˜å†å²è®°å½•\n        await utoolsStorage.set(`history_${testHistory.id}`, testHistory)\n        \n        // éªŒè¯ä¿å­˜ç»“æœ\n        const saved = await utoolsStorage.get(`history_${testHistory.id}`)\n        if (!saved || saved.method !== testHistory.method) {\n          throw new Error('å†å²è®°å½•ä¿å­˜å¤±è´¥')\n        }\n        \n        // æ¸…ç†æµ‹è¯•æ•°æ®\n        await utoolsStorage.remove(`history_${testHistory.id}`)\n        \n        return { historyId: testHistory.id, method: testHistory.method, status: testHistory.status }\n      })\n    }\n  }\n  \n  // è·å–æµ‹è¯•æ‘˜è¦\n  getTestSummary(): { total: number, passed: number, failed: number, skipped: number, warnings: number } {\n    const total = this.results.length\n    const passed = this.results.filter(r => r.status === 'success').length\n    const failed = this.results.filter(r => r.status === 'error').length\n    const skipped = this.results.filter(r => r.status === 'skipped').length\n    const warnings = this.results.filter(r => r.status === 'warning').length\n    \n    return { total, passed, failed, skipped, warnings }\n  }\n  \n  // è·å–æµ‹è¯•ç»“æœ\n  getResults(): TestResult[] {\n    return this.results\n  }\n}\n\n// å¯¼å‡ºæµ‹è¯•å®ä¾‹\nexport const protocolTester = new ProtocolTester()\n\n// ä¾¿æ·æµ‹è¯•å‡½æ•°\nexport async function runProtocolTests(): Promise<TestResult[]> {\n  return await protocolTester.runAllTests()\n}\n\nexport function getTestSummary(): ReturnType<ProtocolTester['getTestSummary']> {\n  return protocolTester.getTestSummary()\n}